# Tesserax: A Lightweight SVG Rendering Library

Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams.

## Key Features

* **Declarative Layouts**: Effortlessly arrange shapes in `Row` or `Column` containers with automatic alignment and spacing.
* **Anchor System**: Connect shapes using semantic anchors like `top`, `bottom`, `left`, `right`, and `center`.
* **Context Manager Support**: Use `with` statements to group shapes naturally within the code.
* **Smart Canvas**: Automatically fit the canvas viewport to the content with adjustable padding.
* **Rich Primitives**: Includes `Rect`, `Square`, `Circle`, `Ellipse`, `Line`, `Arrow`, and `Path`.

## Installation

Tesserax has zero dependencies (literally). It's 100% pure Python, and can be easily installed with `pip`:

```bash
pip install tesserax
```

Or if you're one of the cool kids, using `uv`:

```bash
uv add tesserax
```

If you want support for saving PNG files, install with the `export` extra:

```bash
pip install tesserax[export]
```

## Quick Start

To showcase how **Tesserax** works, we'll build a small illustration step by step. We will start with a blank canvas and gradually add layers of complexity, from simple text to automated layouts and animations.

### Step 1: The Canvas and Text

First, we initialize the `Canvas` and add the central `Text` element. The `Canvas` acts as our root container. By using the `with` statement, any shape we create is automatically added to the canvas context.

```{python}
from tesserax import Canvas, Text

with Canvas() as canvas:
    t = Text(
        "tesserax",
        size=48,
        font="sans-serif",
        fill="navyblue",
        anchor="middle",
    )

canvas.fit().display()
```

The method `Canvas.fit()` ensures the canvas is centered around the bounding box of the illustration. The `display()` method is an IPython/Jupyter/Quarto compatible  shortcut to automatically include the rendered SVG (in all its beautiful vectorial glory) directly in a notebook. But you can also use `Canvas.save()` to generate a plain old, boring SVG file on this, and `str(canvas)` to get the actual SVG code as a plain string.

### Step 2: Adding Geometric Shapes

Next, we add a `Square` and a `Circle`. At this stage, we create them without specific coordinates; they will naturally overlap at the origin until we arrange them. We can manually translate/rotate/scale them with a fluent interface.

```{python}
from tesserax import Square, Circle

with canvas:
    r = Square(30, fill="green", stroke="none").translated(-120, 0)
    c = Circle(20, fill="red", stroke="none").translated(120, 0)

canvas.fit().display()
```

We must call `Canvas.fit()` again to re-center the canvas.

### Step 3: Distribution with Groups

We can arrange these elements more easily with a `Group`. Groups can be created explicitely and elementes added using `Group.add`, or automatically using a `with Group()` statement, or created implicitely with `shape + shape`.
Once created, a `Group` can organize its inner shapes with `align` and `distribute`.

```{python}
from tesserax import Group

with Canvas() as canvas:
    with Group() as g:
        r = Square(30, fill="green", stroke="none")
        t = Text(
            "tesserax",
            size=48,
            font="sans-serif",
            fill="navyblue",
            anchor="middle",
        )
        c = Circle(20, fill="red", stroke="none")

    g.align("horizontal").distribute("horizontal")

canvas.fit(10).display()
```

Groups can also have a transformation, which is stacked with their childrens'. This allows creating complex hierarchical layouts without ever computing explicit pixel positions.

### Step 3a: Using Layouts

An alternative, automatic way to align and distribute items is to use `Layout` subclasses. For example, the `RowLayout` implements the exact same logic we just did manually.

```{python}
from tesserax.layout import RowLayout

with Canvas() as canvas:
    with RowLayout() as logo:
        r = Square(30, fill="green", stroke="none")
        t = Text(
            "tesserax",
            size=48,
            font="sans-serif",
            fill="navyblue",
            anchor="middle",
        )
        c = Circle(20, fill="red", stroke="none")

canvas.fit().display()
```

Layouts are basically `Group` subclasses that perform some sort of automatic organization before rendering.

### Step 4: Adding the Underline

To add some flair, we use the **semantic anchor system** to draw a `Polyline` that connects the bottom of the square to the bottom of the circle.

```{python}
from tesserax import Polyline

with canvas:
    p = Polyline(
        points=[r.anchor("bottom").dy(10), c.anchor("bottom").dy(10)],
        smoothness=1.0,
        stroke="black",
        marker_end="arrow"
    )

canvas.fit(5).display()
```

The `arrow` marker is a default arrow-like shape declared in the canvas, but you can add custom markers using arbitrary shapes, and use them for all lines.

The `Polyline` is a type of `Component`, a very powerful kind of shape that allows encapsulating and reusing complex drawing logic.

### Step 5: Making a Squiggle Line

To add some fancy squiggles, we will use some of the powerful operations in `Polyline`. The first is `subdivide` which creates new points in the mid-point of every segment, recursively. Then other operation is `apply` which accepts a function to modify each point, and can be used to draw mathematical functions.

```{python}
import math

p.subdivide(5).apply(
    lambda p: p.dy(math.sin((p.x / logo.bounds().width * 20 + 5)) * 5)
)

canvas.fit(10).display()
```

The `Shape.bounds()` method computes an axis-align bounding box, in this case, to the whole group that conforms the logo (our previous `RowLayout`).

### Step 6: Animating the Logo

Tesserax also has a powerful, declarative animation system. In this example we use a `Scene` to bring the logo to life. We will rotate the square 90 degrees and make the circle bounce back and forth using a translation loop (using the `+` operator creates a sequence of animations).

```{python}
from tesserax.animation import Scene
from tesserax import deg

scene = Scene(canvas)
scene.play(
    r.animate.rotate(deg(90)),
    c.animate.translate(-10, 0) + c.animate.translate(0, 0),
    duration=1,
)

scene.display()
```

The `Scene.play` method accepts a list of `Animation` which can be constructed manually or using the `Shape.animate` fluent API for common animations. As you can see, `Scene.display` renders the animation to a GIF ready for embedding, but you can also render MP4 videos.

## Core Components

Tesserax comes with all basic components you need to draw the spectrum of SVG shapes.
All shapes support standard SVG attributes like `stroke` and `fill`.

* **Rect & Square**: Defined by width/height or a single size.
* **Circle & Ellipse**: Defined by radii.
* **Groups**: For grouping shapes and applying transforms to them as a single shape.
* **Arrow**: A specialized line that automatically includes an arrowhead marker.
* **Path**: Supports a fluent API for complex paths using `move_to`, `line_to`, `cubic_to`, and `close`.

### Layouts

Layouts are a unique feature of Tesserax to automate the positioning of child elements. We currently have three layouts, but these are very easy to extend:

* **Row**: Aligns shapes horizontally. Baselines can be set to `start`, `middle`, or `end`.
* **Column**: Aligns shapes vertically with `start`, `middle`, or `end` alignment.
* **HierarchicalLayout**: Useful for drawing trees, DAGs, automata, etc.
* **ForceLayout**: Typically used to draw arbitrary graphs with a force-directed algorithm.

### Transforms

Every shape has a `Transform` object allowing for:

* **Translation**: `shape.translated(dx, dy)`.
* **Rotation**: `shape.rotated(degrees)`.
* **Scaling**: `shape.scaled(factor)`.

Groups of shapes also have their own transform, and this can be composed _ad-infinitum_ to create complex drawing.

## Why Tesserax?

In the Python ecosystem, there is a clear divide between **data visualization** (plotting numbers) and **diagrammatic representation** (drawing concepts). Tesserax is built for the latter.

It is designed for researchers, educators, and authors who need the geometric precision of a professional drafting tool combined with the power of a modern programming language.

### Tesserax vs. The Alternatives

#### Precision over Statistics

Libraries like **Matplotlib**, **Seaborn**, or **Altair** are designed to map data points to visual encodings (bars, lines, scatter points).

**The Difference**: Tesserax does not compete with these libraries because it does not render data graphs. You wouldn't use Tesserax to plot a CSV. Instead, Tesserax is for "the rest" of the figures in a paper: the schematics, the geometric proofs, the architectural diagrams, and the algorithmic walkthroughs where exact spatial relationships convey the meaning.

#### Control over Constraints

**Mermaid** and **Graphviz** are excellent for quickly rendering flowcharts using "black-box" layout engines.

**The Difference**: These tools sacrifice control for convenience. If you need an arrow to point exactly at the tangent of a rotated ellipse, or a shape to be sized exactly according to a geometric ratio, Mermaid cannot help you. Tesserax is for **Scientific Drawing**—providing the low-level primitives needed for total layout authority.

#### The "TikZ for Python" Philosophy

**TikZ** is the industry standard for academic figures, but it requires learning a specialized, often cryptic macro language.

**The Difference**: Tesserax brings the "low-level, total-control" philosophy of TikZ into **Python 3.12**. You get coordinate-invariant precision and semantic anchoring while using Python’s loops, logic, and types. We are building from the bottom up: starting with geometric atoms and moving toward high-level scientific abstractions (like automated neural network architectures or commutative diagrams) that maintain the ability to "drop down" and tweak a single pixel.

### The SVG Advantage

While TikZ is the gold standard for LaTeX-based PDF generation, it belongs to a "print-first" era. Tesserax leverages **SVG (Scalable Vector Graphics)** as its native format, offering a portability that TikZ cannot match without significant friction.

* **Native Web Rendering**: Tesserax figures are native SVGs. They render instantly in any browser, remain crisp at any zoom level, and can be embedded directly into HTML or Markdown (via Quarto) without conversion.
* **WYSIWYG Portability**: Converting TikZ to SVG for blog posts or online journals often results in broken fonts or misaligned elements. Because Tesserax *starts* with SVG, what you see in your development notebook is exactly what appears in your final PDF and your website.
* **Accessibility & Interaction**: Unlike static PDFs, Tesserax SVGs can include metadata and ARIA labels for screen readers. Since they are part of the DOM, they can also be styled with CSS or even animated for interactive educational content.
* **Perfect Print**: SVG is fully convertible to high-quality, vector-perfect PDF, meeting the highest standards for academic journals and book publishing.

## Contribution

Tesserax is free as in both free beer and free speech. License is MIT.

Contributions are always welcomed! Fork, clone, and submit a pull request.
